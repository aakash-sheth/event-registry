name: Deploy to AWS Staging

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_BACKEND_REPOSITORY: event-registry-backend-staging
  ECR_FRONTEND_REPOSITORY: event-registry-frontend-staging
  ECS_CLUSTER_NAME: event-registry-staging
  ECS_BACKEND_SERVICE: backend-service
  ECS_FRONTEND_SERVICE: frontend-service

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for missing migrations
        run: |
          echo "üîç Checking for missing Django migrations..."
          cd backend
          
          python3 -m venv /tmp/venv
          source /tmp/venv/bin/activate
          
          echo "Installing dependencies for migration check..."
          # Install setuptools first (required by djangorestframework-simplejwt)
          pip install -q setuptools 2>&1 | tee /tmp/pip_install.log || {
            echo "‚ùå ERROR: Failed to install setuptools"
            exit 1
          }
          
          # Install all requirements except psycopg2-binary (using SQLite instead)
          # Create a temporary requirements file without psycopg2-binary
          grep -v "psycopg2-binary" requirements.txt > /tmp/requirements_migration.txt
          pip install -q -r /tmp/requirements_migration.txt 2>&1 | tee -a /tmp/pip_install.log || {
            echo "‚ùå ERROR: Failed to install dependencies"
            echo "Installation log:"
            cat /tmp/pip_install.log
            exit 1
          }
          
          # Use SQLite for migration check (no database connection needed)
          # Set DATABASE_URL to SQLite to avoid psycopg2 requirement
          export DATABASE_URL="sqlite:///tmp/migration_check.db"
          export DJANGO_SECRET_KEY="dummy-for-migration-check"
          export DEBUG="False"
          
          echo "Running makemigrations --check --dry-run..."
          MIGRATION_OUTPUT=$(python manage.py makemigrations --check --dry-run 2>&1)
          MIGRATION_EXIT=$?
          
          # makemigrations --check returns:
          # - Exit code 0: No migrations needed (success)
          # - Exit code 1: Migrations needed (failure)
          # - Exit code > 1: Error occurred (failure)
          if [ $MIGRATION_EXIT -eq 0 ]; then
            echo "‚úÖ All migrations are up to date"
            echo "$MIGRATION_OUTPUT"
          else
            echo "‚ùå ERROR: Missing migrations detected or error occurred!"
            echo ""
            echo "=== Full Migration Check Output ==="
            echo "$MIGRATION_OUTPUT"
            echo "=================================="
            echo ""
            if [ $MIGRATION_EXIT -eq 1 ]; then
              echo "Model changes were pushed without corresponding migration files."
              echo "This will cause deployment failures and runtime errors."
              echo ""
              echo "To fix:"
              echo "  1. cd backend && python manage.py makemigrations"
              echo "  2. Review the generated migration files"
              echo "  3. git add backend/apps/*/migrations/ && git commit -m 'Add missing migrations' && git push"
              echo "  4. Re-run this deployment"
            else
              echo "‚ö†Ô∏è  makemigrations command failed with exit code $MIGRATION_EXIT"
              echo "   This indicates a configuration or dependency issue."
              echo "   Check the output above for specific error messages."
            fi
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push backend image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f backend/Dockerfile.prod -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG ./backend
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest
          echo "BACKEND_IMAGE=$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build, tag, and push frontend image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Use NEXT_PUBLIC_API_BASE directly (for API calls - should point to ALB)
          # FRONTEND_URL is only for frontend display URLs, not API calls
          NEXT_PUBLIC_API_BASE=$(aws ssm get-parameter --name "/event-registry-staging/NEXT_PUBLIC_API_BASE" --query "Parameter.Value" --output text 2>/dev/null || echo "")
          
          if [ -z "$NEXT_PUBLIC_API_BASE" ]; then
            # Fallback: construct from ALB_DNS
            ALB_DNS=$(aws ssm get-parameter --name "/event-registry-staging/ALB_DNS" --query "Parameter.Value" --output text 2>/dev/null || echo "staging-alb-33342285.us-east-1.elb.amazonaws.com")
            NEXT_PUBLIC_API_BASE="http://${ALB_DNS}"
            echo "‚ö†Ô∏è  Using fallback: constructed from ALB_DNS"
          else
            echo "‚úÖ Using NEXT_PUBLIC_API_BASE from SSM: ${NEXT_PUBLIC_API_BASE}"
          fi
          
          # Get FRONTEND_URL for display purposes (company homepage, meta tags, etc.)
          FRONTEND_URL=$(aws ssm get-parameter --name "/event-registry-staging/FRONTEND_URL" --query "Parameter.Value" --output text 2>/dev/null || echo "")
          
          # Fetch brand name from SSM (default: Ekfern)
          NEXT_PUBLIC_BRAND_NAME=$(aws ssm get-parameter --name "/event-registry-staging/NEXT_PUBLIC_BRAND_NAME" --query "Parameter.Value" --output text 2>/dev/null || echo "Ekfern")
          
          # Fetch CloudFront image domain from SSM (for converting S3 URLs to CloudFront URLs in meta tags)
          NEXT_PUBLIC_CLOUDFRONT_IMAGE_DOMAIN=$(aws ssm get-parameter --name "/event-registry-staging/CLOUDFRONT_IMAGE_DOMAIN" --query "Parameter.Value" --output text 2>/dev/null || echo "")
          
          # Company homepage uses FRONTEND_URL if available, otherwise NEXT_PUBLIC_API_BASE
          NEXT_PUBLIC_COMPANY_HOMEPAGE="${FRONTEND_URL:-$NEXT_PUBLIC_API_BASE}"
          
          echo "Building frontend with NEXT_PUBLIC_API_BASE=${NEXT_PUBLIC_API_BASE}"
          echo "Building frontend with NEXT_PUBLIC_BRAND_NAME=${NEXT_PUBLIC_BRAND_NAME}"
          echo "Building frontend with NEXT_PUBLIC_COMPANY_HOMEPAGE=${NEXT_PUBLIC_COMPANY_HOMEPAGE}"
          echo "Building frontend with NEXT_PUBLIC_CLOUDFRONT_IMAGE_DOMAIN=${NEXT_PUBLIC_CLOUDFRONT_IMAGE_DOMAIN}"
          echo "Building frontend with COMMIT_SHA=${IMAGE_TAG}"
          
          # Build with Docker buildx
          # COMMIT_SHA build arg ensures cache is invalidated when code changes
          # Cache mount for npm speeds up dependency installation
          docker buildx build \
            --platform linux/amd64 \
            --file frontend/Dockerfile.prod \
            --build-arg NEXT_PUBLIC_API_BASE="${NEXT_PUBLIC_API_BASE}" \
            --build-arg NEXT_PUBLIC_BRAND_NAME="${NEXT_PUBLIC_BRAND_NAME}" \
            --build-arg NEXT_PUBLIC_COMPANY_HOMEPAGE="${NEXT_PUBLIC_COMPANY_HOMEPAGE}" \
            --build-arg NEXT_PUBLIC_CLOUDFRONT_IMAGE_DOMAIN="${NEXT_PUBLIC_CLOUDFRONT_IMAGE_DOMAIN}" \
            --build-arg COMMIT_SHA="${IMAGE_TAG}" \
            --tag $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG \
            --tag $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest \
            --push \
            ./frontend
          
          echo "FRONTEND_IMAGE=$ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Verify images exist in ECR
        run: |
          BACKEND_COUNT=$(aws ecr describe-images \
            --repository-name ${{ env.ECR_BACKEND_REPOSITORY }} \
            --query 'length(imageDetails)' \
            --output text)
          
          if [ "$BACKEND_COUNT" = "0" ]; then
            echo "‚ùå ERROR: No backend images found in ECR!"
            exit 1
          fi
          
          FRONTEND_COUNT=$(aws ecr describe-images \
            --repository-name ${{ env.ECR_FRONTEND_REPOSITORY }} \
            --query 'length(imageDetails)' \
            --output text)
          
          if [ "$FRONTEND_COUNT" = "0" ]; then
            echo "‚ùå ERROR: No frontend images found in ECR!"
            exit 1
          fi
          
          echo "‚úÖ Images verified: backend ($BACKEND_COUNT), frontend ($FRONTEND_COUNT)"

      - name: Run database migrations
        timeout-minutes: 10
        run: |
          TASK_DEF="backend-migration-task"
          if ! aws ecs describe-task-definition --task-definition $TASK_DEF >/dev/null 2>&1; then
            TASK_DEF="backend-task"
          fi
          
          SUBNET_1="${{ secrets.ECS_PRIVATE_SUBNET_1 }}"
          SUBNET_2="${{ secrets.ECS_PRIVATE_SUBNET_2 }}"
          SG_ID="${{ secrets.ECS_BACKEND_SECURITY_GROUP }}"
          
          if [ -z "$SUBNET_1" ] || [ -z "$SUBNET_2" ] || [ -z "$SG_ID" ]; then
            echo "‚ùå ERROR: Missing secrets: ECS_PRIVATE_SUBNET_1, ECS_PRIVATE_SUBNET_2, ECS_BACKEND_SECURITY_GROUP"
            exit 1
          fi
          
          echo "Starting migration task..."
          MIGRATION_TASK=$(aws ecs run-task \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --task-definition $TASK_DEF \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_1,$SUBNET_2],securityGroups=[$SG_ID],assignPublicIp=DISABLED}" \
            --overrides '{"containerOverrides":[{"name":"backend","command":["python","manage.py","migrate"]}]}' \
            --query 'tasks[0].taskArn' \
            --output text)
          
          if [ -z "$MIGRATION_TASK" ] || [ "$MIGRATION_TASK" = "None" ]; then
            echo "‚ùå Failed to start migration task"
            exit 1
          fi
          
          echo "Waiting for migration to complete..."
          aws ecs wait tasks-stopped \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK" || true
          
          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK" \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)
          
          TASK_STATUS=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK" \
            --query 'tasks[0].lastStatus' \
            --output text)
          
          STOPPED_REASON=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK" \
            --query 'tasks[0].stoppedReason' \
            --output text)
          
          if [ "$EXIT_CODE" = "0" ]; then
            echo "‚úÖ Migration completed successfully"
          else
            echo "‚ùå Migration failed (exit code: $EXIT_CODE, status: $TASK_STATUS)"
            if [ -n "$STOPPED_REASON" ] && [ "$STOPPED_REASON" != "None" ]; then
              echo "Reason: $STOPPED_REASON"
            fi
            echo "Check logs: aws logs tail /ecs/event-registry-staging/backend --follow"
            exit 1
          fi

      - name: Update backend ECS service
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --service ${{ env.ECS_BACKEND_SERVICE }} \
            --force-new-deployment

      - name: Update frontend ECS service
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --service ${{ env.ECS_FRONTEND_SERVICE }} \
            --force-new-deployment

      - name: Wait for backend service to stabilize
        timeout-minutes: 20
        run: |
          echo "Waiting for backend service to stabilize..."
          if aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --services ${{ env.ECS_BACKEND_SERVICE }}; then
            echo "‚úÖ Backend service is stable"
          else
            echo "‚ùå Backend service did not stabilize within timeout"
            echo ""
            echo "=== Service Status ==="
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_BACKEND_SERVICE }} \
              --query 'services[0].{Desired:desiredCount,Running:runningCount,Pending:pendingCount,Deployments:deployments[*].{Status:status,Running:runningCount,Desired:desiredCount,Id:id}}' \
              --output json
            echo ""
            echo "=== Recent Service Events (last 10) ==="
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_BACKEND_SERVICE }} \
              --query 'services[0].events[:10]' \
              --output table
            echo ""
            echo "=== Running Tasks Status ==="
            TASKS=$(aws ecs list-tasks \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --service-name ${{ env.ECS_BACKEND_SERVICE }} \
              --query 'taskArns[]' \
              --output text)
            if [ -n "$TASKS" ]; then
              for TASK in $TASKS; do
                echo "--- Task: $TASK ---"
                aws ecs describe-tasks \
                  --cluster ${{ env.ECS_CLUSTER_NAME }} \
                  --tasks "$TASK" \
                  --query 'tasks[0].{LastStatus:lastStatus,DesiredStatus:desiredStatus,HealthStatus:healthStatus,StoppedReason:stoppedReason,StoppedAt:stoppedAt,Containers:containers[*].{Name:name,LastStatus:lastStatus,ExitCode:exitCode,Reason:reason}}' \
                  --output json
                echo ""
              done
            else
              echo "No running tasks found"
            fi
            echo ""
            echo "=== Stopped Tasks (last 5) ==="
            STOPPED_TASKS=$(aws ecs list-tasks \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --service-name ${{ env.ECS_BACKEND_SERVICE }} \
              --desired-status STOPPED \
              --max-items 5 \
              --query 'taskArns[]' \
              --output text)
            if [ -n "$STOPPED_TASKS" ]; then
              for TASK in $STOPPED_TASKS; do
                echo "--- Stopped Task: $TASK ---"
                aws ecs describe-tasks \
                  --cluster ${{ env.ECS_CLUSTER_NAME }} \
                  --tasks "$TASK" \
                  --query 'tasks[0].{LastStatus:lastStatus,StoppedReason:stoppedReason,StoppedAt:stoppedAt,Containers:containers[*].{Name:name,ExitCode:exitCode,Reason:reason}}' \
                  --output json
                echo ""
              done
            fi
            echo ""
            echo "=== Check CloudWatch Logs ==="
            echo "Run: aws logs tail /ecs/${{ env.ECS_CLUSTER_NAME }}/backend --follow"
            exit 1
          fi

      - name: Wait for frontend service to stabilize
        timeout-minutes: 20
        run: |
          if aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --services ${{ env.ECS_FRONTEND_SERVICE }}; then
            echo "‚úÖ Frontend service is stable"
          else
            echo "‚ùå Frontend service did not stabilize within timeout"
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_FRONTEND_SERVICE }} \
              --query 'services[0].{Desired:desiredCount,Running:runningCount,Pending:pendingCount}' \
              --output table
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_FRONTEND_SERVICE }} \
              --query 'services[0].events[:3]' \
              --output table
            exit 1
          fi

      - name: Verify health checks
        continue-on-error: true
        run: |
          ALB_DNS=$(aws ssm get-parameter --name "/event-registry-staging/ALB_DNS" --query "Parameter.Value" --output text 2>/dev/null || echo "")
          
          if [ -z "$ALB_DNS" ]; then
            echo "‚ö†Ô∏è  ALB_DNS not set in SSM, skipping health check"
            exit 0
          fi
          
          # Capture HTTP code and response body for debugging
          # Use HTTPS if ALB_DNS starts with https://, otherwise use HTTP
          if [[ "$ALB_DNS" == https://* ]]; then
            HEALTH_URL="${ALB_DNS}/api/health"
          else
            HEALTH_URL="http://${ALB_DNS}/api/health"
          fi
          
          HTTP_CODE=$(curl -s -o /tmp/health_response.json -w "%{http_code}" -m 10 "$HEALTH_URL" 2>&1)
          CURL_EXIT=$?
          
          if [ "$CURL_EXIT" -eq 0 ] && [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Backend health check passed"
          else
            echo "‚ö†Ô∏è  Backend health check failed (non-critical)"
            echo "   HTTP Status: ${HTTP_CODE:-unknown}"
            if [ -f /tmp/health_response.json ]; then
              echo "   Response: $(cat /tmp/health_response.json)"
            fi
            if [ "$CURL_EXIT" -ne 0 ]; then
              echo "   Curl error: exit code $CURL_EXIT"
            fi
          fi