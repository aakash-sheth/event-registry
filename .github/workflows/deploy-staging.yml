name: Deploy to AWS Staging

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_BACKEND_REPOSITORY: event-registry-backend-staging
  ECR_FRONTEND_REPOSITORY: event-registry-frontend-staging
  ECS_CLUSTER_NAME: event-registry-staging
  ECS_BACKEND_SERVICE: backend-service
  ECS_FRONTEND_SERVICE: frontend-service

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for missing migrations
        run: |
          echo "üîç Checking for missing Django migrations..."
          cd backend
          
          python3 -m venv /tmp/venv
          source /tmp/venv/bin/activate
          
          echo "Installing dependencies for migration check..."
          # Install setuptools first (required by djangorestframework-simplejwt)
          pip install -q setuptools 2>&1 | tee /tmp/pip_install.log || {
            echo "‚ùå ERROR: Failed to install setuptools"
            exit 1
          }
          
          # Install all requirements except psycopg2-binary (using SQLite instead)
          # Create a temporary requirements file without psycopg2-binary
          grep -v "psycopg2-binary" requirements.txt > /tmp/requirements_migration.txt
          pip install -q -r /tmp/requirements_migration.txt 2>&1 | tee -a /tmp/pip_install.log || {
            echo "‚ùå ERROR: Failed to install dependencies"
            echo "Installation log:"
            cat /tmp/pip_install.log
            exit 1
          }
          
          # Use SQLite for migration check (no database connection needed)
          # Set DATABASE_URL to SQLite to avoid psycopg2 requirement
          export DATABASE_URL="sqlite:///tmp/migration_check.db"
          export DJANGO_SECRET_KEY="dummy-for-migration-check"
          export DEBUG="False"
          
          echo "Running makemigrations --check --dry-run..."
          MIGRATION_OUTPUT=$(python manage.py makemigrations --check --dry-run 2>&1)
          MIGRATION_EXIT=$?
          
          # makemigrations --check returns:
          # - Exit code 0: No migrations needed (success)
          # - Exit code 1: Migrations needed (failure)
          # - Exit code > 1: Error occurred (failure)
          if [ $MIGRATION_EXIT -eq 0 ]; then
            echo "‚úÖ All migrations are up to date"
            echo "$MIGRATION_OUTPUT"
          else
            echo "‚ùå ERROR: Missing migrations detected or error occurred!"
            echo ""
            echo "=== Full Migration Check Output ==="
            echo "$MIGRATION_OUTPUT"
            echo "=================================="
            echo ""
            if [ $MIGRATION_EXIT -eq 1 ]; then
              echo "Model changes were pushed without corresponding migration files."
              echo "This will cause deployment failures and runtime errors."
              echo ""
              echo "To fix:"
              echo "  1. cd backend && python manage.py makemigrations"
              echo "  2. Review the generated migration files"
              echo "  3. git add backend/apps/*/migrations/ && git commit -m 'Add missing migrations' && git push"
              echo "  4. Re-run this deployment"
            else
              echo "‚ö†Ô∏è  makemigrations command failed with exit code $MIGRATION_EXIT"
              echo "   This indicates a configuration or dependency issue."
              echo "   Check the output above for specific error messages."
            fi
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push backend image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f backend/Dockerfile.prod -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG ./backend
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest
          echo "BACKEND_IMAGE=$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Build, tag, and push frontend image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f frontend/Dockerfile.prod -t $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG ./frontend
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest
          echo "FRONTEND_IMAGE=$ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Verify images exist in ECR
        run: |
          BACKEND_COUNT=$(aws ecr describe-images \
            --repository-name ${{ env.ECR_BACKEND_REPOSITORY }} \
            --query 'length(imageDetails)' \
            --output text)
          
          if [ "$BACKEND_COUNT" = "0" ]; then
            echo "‚ùå ERROR: No backend images found in ECR!"
            exit 1
          fi
          
          FRONTEND_COUNT=$(aws ecr describe-images \
            --repository-name ${{ env.ECR_FRONTEND_REPOSITORY }} \
            --query 'length(imageDetails)' \
            --output text)
          
          if [ "$FRONTEND_COUNT" = "0" ]; then
            echo "‚ùå ERROR: No frontend images found in ECR!"
            exit 1
          fi
          
          echo "‚úÖ Images verified: backend ($BACKEND_COUNT), frontend ($FRONTEND_COUNT)"

      - name: Run database migrations
        timeout-minutes: 10
        run: |
          TASK_DEF="backend-migration-task"
          if ! aws ecs describe-task-definition --task-definition $TASK_DEF >/dev/null 2>&1; then
            TASK_DEF="backend-task"
          fi
          
          SUBNET_1="${{ secrets.ECS_PRIVATE_SUBNET_1 }}"
          SUBNET_2="${{ secrets.ECS_PRIVATE_SUBNET_2 }}"
          SG_ID="${{ secrets.ECS_BACKEND_SECURITY_GROUP }}"
          
          if [ -z "$SUBNET_1" ] || [ -z "$SUBNET_2" ] || [ -z "$SG_ID" ]; then
            echo "‚ùå ERROR: Missing secrets: ECS_PRIVATE_SUBNET_1, ECS_PRIVATE_SUBNET_2, ECS_BACKEND_SECURITY_GROUP"
            exit 1
          fi
          
          echo "Starting migration task..."
          MIGRATION_TASK=$(aws ecs run-task \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --task-definition $TASK_DEF \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_1,$SUBNET_2],securityGroups=[$SG_ID],assignPublicIp=DISABLED}" \
            --overrides '{"containerOverrides":[{"name":"backend","command":["python","manage.py","migrate"]}]}' \
            --query 'tasks[0].taskArn' \
            --output text)
          
          if [ -z "$MIGRATION_TASK" ] || [ "$MIGRATION_TASK" = "None" ]; then
            echo "‚ùå Failed to start migration task"
            exit 1
          fi
          
          echo "Waiting for migration to complete..."
          aws ecs wait tasks-stopped \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK" || true
          
          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK" \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)
          
          TASK_STATUS=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK" \
            --query 'tasks[0].lastStatus' \
            --output text)
          
          STOPPED_REASON=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK" \
            --query 'tasks[0].stoppedReason' \
            --output text)
          
          if [ "$EXIT_CODE" = "0" ]; then
            echo "‚úÖ Migration completed successfully"
          else
            echo "‚ùå Migration failed (exit code: $EXIT_CODE, status: $TASK_STATUS)"
            if [ -n "$STOPPED_REASON" ] && [ "$STOPPED_REASON" != "None" ]; then
              echo "Reason: $STOPPED_REASON"
            fi
            echo "Check logs: aws logs tail /ecs/event-registry-staging/backend --follow"
            exit 1
          fi

      - name: Update backend ECS service
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --service ${{ env.ECS_BACKEND_SERVICE }} \
            --force-new-deployment

      - name: Update frontend ECS service
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --service ${{ env.ECS_FRONTEND_SERVICE }} \
            --force-new-deployment

      - name: Wait for backend service to stabilize
        timeout-minutes: 20
        run: |
          if aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --services ${{ env.ECS_BACKEND_SERVICE }}; then
            echo "‚úÖ Backend service is stable"
          else
            echo "‚ùå Backend service did not stabilize within timeout"
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_BACKEND_SERVICE }} \
              --query 'services[0].{Desired:desiredCount,Running:runningCount,Pending:pendingCount}' \
              --output table
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_BACKEND_SERVICE }} \
              --query 'services[0].events[:3]' \
              --output table
            exit 1
          fi

      - name: Wait for frontend service to stabilize
        timeout-minutes: 20
        run: |
          if aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --services ${{ env.ECS_FRONTEND_SERVICE }}; then
            echo "‚úÖ Frontend service is stable"
          else
            echo "‚ùå Frontend service did not stabilize within timeout"
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_FRONTEND_SERVICE }} \
              --query 'services[0].{Desired:desiredCount,Running:runningCount,Pending:pendingCount}' \
              --output table
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_FRONTEND_SERVICE }} \
              --query 'services[0].events[:3]' \
              --output table
            exit 1
          fi

      - name: Verify health checks
        continue-on-error: true
        run: |
          ALB_DNS=$(aws ssm get-parameter --name "/event-registry-staging/ALB_DNS" --query "Parameter.Value" --output text 2>/dev/null || echo "")
          
          if [ -z "$ALB_DNS" ]; then
            echo "‚ö†Ô∏è  ALB_DNS not set in SSM, skipping health check"
            exit 0
          fi
          
          # Capture HTTP code and response body for debugging
          HTTP_CODE=$(curl -s -o /tmp/health_response.json -w "%{http_code}" -m 10 https://$ALB_DNS/api/health 2>&1)
          CURL_EXIT=$?
          
          if [ "$CURL_EXIT" -eq 0 ] && [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Backend health check passed"
          else
            echo "‚ö†Ô∏è  Backend health check failed (non-critical)"
            echo "   HTTP Status: ${HTTP_CODE:-unknown}"
            if [ -f /tmp/health_response.json ]; then
              echo "   Response: $(cat /tmp/health_response.json)"
            fi
            if [ "$CURL_EXIT" -ne 0 ]; then
              echo "   Curl error: exit code $CURL_EXIT"
            fi
          fi