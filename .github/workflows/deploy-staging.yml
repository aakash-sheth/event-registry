name: Deploy to AWS Staging

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_BACKEND_REPOSITORY: event-registry-backend-staging
  ECR_FRONTEND_REPOSITORY: event-registry-frontend-staging
  ECS_CLUSTER_NAME: event-registry-staging
  ECS_BACKEND_SERVICE: backend-service
  ECS_FRONTEND_SERVICE: frontend-service

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for missing migrations
        run: |
          echo "üîç Checking for missing Django migrations..."
          
          cd backend
          
          # Set up minimal Python environment for Django check
          python3 -m venv /tmp/venv
          source /tmp/venv/bin/activate
          pip install -q django psycopg2-binary > /dev/null 2>&1
          
          # Set dummy environment variables (we're not connecting to DB, just checking models)
          export DATABASE_URL="postgresql://dummy:dummy@localhost:5432/dummy"
          export DJANGO_SECRET_KEY="dummy-for-migration-check"
          export DEBUG="False"
          
          # Check if makemigrations would create new migration files
          echo "Running makemigrations --check --dry-run..."
          if python manage.py makemigrations --check --dry-run 2>&1 | grep -q "No changes detected"; then
            echo "‚úÖ All migrations are up to date"
          else
            echo ""
            echo "‚ùå ERROR: Missing migrations detected!"
            echo ""
            echo "Model changes were pushed without corresponding migration files."
            echo "This will cause deployment failures and runtime errors."
            echo ""
            echo "To fix this:"
            echo "  1. Create migrations locally:"
            echo "     cd backend && python manage.py makemigrations"
            echo ""
            echo "  2. Review the generated migration files"
            echo ""
            echo "  3. Commit and push the migration files:"
            echo "     git add backend/apps/*/migrations/"
            echo "     git commit -m 'Add missing migrations'"
            echo "     git push origin main"
            echo ""
            echo "  4. Re-run this deployment"
            echo ""
            echo "‚ö†Ô∏è  DO NOT skip this step - missing migrations will break production!"
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push backend image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f backend/Dockerfile.prod -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG ./backend
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest
          echo "BACKEND_IMAGE=$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Build, tag, and push frontend image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f frontend/Dockerfile.prod -t $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG ./frontend
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest
          echo "FRONTEND_IMAGE=$ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Verify images exist in ECR
        run: |
          echo "Verifying images were pushed successfully..."
          BACKEND_COUNT=$(aws ecr describe-images \
            --repository-name ${{ env.ECR_BACKEND_REPOSITORY }} \
            --query 'length(imageDetails)' \
            --output text)
          
          if [ "$BACKEND_COUNT" = "0" ]; then
            echo "‚ùå ERROR: No backend images found in ECR!"
            exit 1
          fi
          echo "‚úÖ Backend images found: $BACKEND_COUNT"
          
          FRONTEND_COUNT=$(aws ecr describe-images \
            --repository-name ${{ env.ECR_FRONTEND_REPOSITORY }} \
            --query 'length(imageDetails)' \
            --output text)
          
          if [ "$FRONTEND_COUNT" = "0" ]; then
            echo "‚ùå ERROR: No frontend images found in ECR!"
            exit 1
          fi
          echo "‚úÖ Frontend images found: $FRONTEND_COUNT"

      - name: Run database migrations
        timeout-minutes: 10
        run: |
          # Use migration task if exists, otherwise use backend-task
          TASK_DEF="backend-migration-task"
          if ! aws ecs describe-task-definition --task-definition $TASK_DEF >/dev/null 2>&1; then
            echo "Migration task not found, using backend-task instead"
            TASK_DEF="backend-task"
          fi
          
          # Get subnet and security group IDs from secrets
          SUBNET_1="${{ secrets.ECS_PRIVATE_SUBNET_1 }}"
          SUBNET_2="${{ secrets.ECS_PRIVATE_SUBNET_2 }}"
          SG_ID="${{ secrets.ECS_BACKEND_SECURITY_GROUP }}"
          
          if [ -z "$SUBNET_1" ] || [ -z "$SUBNET_2" ] || [ -z "$SG_ID" ]; then
            echo "‚ö†Ô∏è  ERROR: Subnet or Security Group secrets not set in GitHub!"
            echo "   Please add these secrets:"
            echo "   - ECS_PRIVATE_SUBNET_1"
            echo "   - ECS_PRIVATE_SUBNET_2"
            echo "   - ECS_BACKEND_SECURITY_GROUP"
            exit 1
          fi
          
          echo "Starting migration task..."
          MIGRATION_TASK=$(aws ecs run-task \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --task-definition $TASK_DEF \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_1,$SUBNET_2],securityGroups=[$SG_ID],assignPublicIp=DISABLED}" \
            --overrides '{"containerOverrides":[{"name":"backend","command":["python","manage.py","migrate"]}]}' \
            --query 'tasks[0].taskArn' \
            --output text)
          
          if [ -z "$MIGRATION_TASK" ] || [ "$MIGRATION_TASK" = "None" ]; then
            echo "‚ùå Failed to start migration task"
            exit 1
          fi
          
          echo "Migration task started: $MIGRATION_TASK"
          echo "Waiting for migration to complete (max 10 minutes)..."
          
          # Wait for task to stop (step has 10 minute timeout)
          if aws ecs wait tasks-stopped \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK"; then
            echo "Migration task completed"
          else
            echo "‚ö†Ô∏è  Migration task timeout or still running"
          fi
          
          # Get task status
          TASK_STATUS=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK" \
            --query 'tasks[0].lastStatus' \
            --output text)
          
          # Check exit code
          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK" \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)
          
          # Get stopped reason if task failed to start
          STOPPED_REASON=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --tasks "$MIGRATION_TASK" \
            --query 'tasks[0].stoppedReason' \
            --output text)
          
          if [ "$EXIT_CODE" = "0" ]; then
            echo "‚úÖ Migration completed successfully"
          elif [ "$EXIT_CODE" = "None" ] || [ "$TASK_STATUS" != "STOPPED" ]; then
            echo "‚ö†Ô∏è  Migration task stopped before completion or did not start properly"
            echo "Task status: $TASK_STATUS"
            if [ -n "$STOPPED_REASON" ] && [ "$STOPPED_REASON" != "None" ]; then
              echo "Stopped reason: $STOPPED_REASON"
            fi
            echo "Check logs: aws logs tail /ecs/event-registry-staging/backend --follow"
            exit 1
          else
            echo "‚ùå Migration failed with exit code: $EXIT_CODE"
            if [ -n "$STOPPED_REASON" ] && [ "$STOPPED_REASON" != "None" ]; then
              echo "Stopped reason: $STOPPED_REASON"
            fi
            echo "Check logs: aws logs tail /ecs/event-registry-staging/backend --follow"
            exit 1
          fi

      - name: Update backend ECS service
        run: |
          echo "Updating backend service..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --service ${{ env.ECS_BACKEND_SERVICE }} \
            --force-new-deployment

      - name: Update frontend ECS service
        run: |
          echo "Updating frontend service..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --service ${{ env.ECS_FRONTEND_SERVICE }} \
            --force-new-deployment

      - name: Wait for backend service to stabilize
        timeout-minutes: 20
        run: |
          echo "Waiting for backend service to stabilize (max 20 minutes)..."
          if aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --services ${{ env.ECS_BACKEND_SERVICE }}; then
            echo "‚úÖ Backend service is stable"
          else
            echo "‚ö†Ô∏è  Backend service did not stabilize within timeout"
            echo "Checking service status..."
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_BACKEND_SERVICE }} \
              --query 'services[0].{Desired:desiredCount,Running:runningCount,Pending:pendingCount}' \
              --output table
            echo "Recent events:"
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_BACKEND_SERVICE }} \
              --query 'services[0].events[:3]' \
              --output table
            exit 1
          fi

      - name: Wait for frontend service to stabilize
        timeout-minutes: 20
        run: |
          echo "Waiting for frontend service to stabilize (max 20 minutes)..."
          if aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER_NAME }} \
            --services ${{ env.ECS_FRONTEND_SERVICE }}; then
            echo "‚úÖ Frontend service is stable"
          else
            echo "‚ö†Ô∏è  Frontend service did not stabilize within timeout"
            echo "Checking service status..."
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_FRONTEND_SERVICE }} \
              --query 'services[0].{Desired:desiredCount,Running:runningCount,Pending:pendingCount}' \
              --output table
            echo "Recent events:"
            aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_NAME }} \
              --services ${{ env.ECS_FRONTEND_SERVICE }} \
              --query 'services[0].events[:3]' \
              --output table
            exit 1
          fi

      - name: Verify health checks
        continue-on-error: true
        run: |
          # Get ALB DNS name from SSM
          ALB_DNS=$(aws ssm get-parameter --name "/event-registry-staging/ALB_DNS" --query "Parameter.Value" --output text 2>/dev/null || echo "")
          
          if [ -z "$ALB_DNS" ]; then
            echo "‚ö†Ô∏è  ALB_DNS not set in SSM, skipping health check"
            exit 0
          fi
          
          echo "Checking backend health at https://$ALB_DNS/api/health"
          if curl -f -m 10 https://$ALB_DNS/api/health; then
            echo "‚úÖ Backend health check passed"
          else
            echo "‚ö†Ô∏è  Backend health check failed (non-critical)"
          fi